谈谈redis的使用

​	redis作为一款开源的nosql数据库常用于数据缓存，其特点是key、value的键值对存储，通过hash计算key将value存入内存中，因此redis的查询性能非常优异，同样因为是将数据存储在内存中，因此对内存的消耗很大。

​	redis的常用业务场景是将数据缓存到内存中，提供快速的查询服务的同时可以减轻关系型数据库服务器的压力，基于该特点，应当被缓存的数据应该具有一个共同点：经常需要用到但又不会经常发生改变的数据；如首页，任何网站的首页都是属于并发量很大但又不经常改动的，这时就可以将首页数据缓存到redis中，如果首页数据发生修改后也可以将修改后的数据更新到redis中，然后就是热点数据，热点数据一般是某个周期内网站的常用数据，将其缓存到内存中不仅可以提高快速的数据响应，还可以降低数据库服务器压力，等到热点数据周期更新后同时更新redis中的数据即可。

​	将数据缓存到数据库确实可以提供快速的数据响应提升用户的使用体验，但是该策略同样伴有隐患：雪崩。一般的业务逻辑都是如果redis的数据的缓存失效后都会从数据库获取并重新更新到redis中；另一种极端情况则是redis服务器挂了，数据都会从数据库服务器获取，而redis缓存的数据都是高并发数据，数据库服务器承受不了并发压力也一并挂了进而导致整个网站都挂掉，为此，针对redis服务器集群以及设计多重缓存对提高网站高可用是很有必要的。

​	redis支持的常用数据类型包括：字符串（String）、散列（hash）、列表（list）、集合（set）、有序集合（sorted set）。

​	字符串（string）：简单的key：value存储；key作为redis的key，value则是存储的字符串数据

​	散列（hash）：通过hash算法存储的key：filedkey：value存储；key作为redis的key；filedkey可以理解为java中的hashmap的key，value亦是如此；每个散列的存储容量为2的32次方-1，通过java的 （（long）2<<31）-1）得出结果，结果为4294967295；这里解释一下（（long）2<<31）-1）计算公式，此处所用属于位运算的一种，直接计算二进制而得到结果，因为本身已经包含2，所以只需位移31次就可以达到2的32次方的效果。

​	列表（list）：key：【value1，value2，value3、、、】；key作为redis的redis的key，对应的存储的则是大量的value，用Java的说法就是持有大量对象的容器；其容量为2的32次方减一，其行为与java中的list高度相似；使用redis的list可以轻易的达到队列的效果：从头添加，从尾获取，需要注意一点的是lpush默认是从头添加的。redis的列表支持正向索引、反向索引、正向切片索引、反向切片索引，以下将一一举例。正向索引：lindex key 1则代表获取list中的索引为1的元素；反向索引：lindex key -1,该语法代表获取最大索引值的元素,大白话就是取倒数第一个元素,若索引的位置是-2,就代表取倒数第二个；正向切片索引：lrange key 0 3,该语法表示获取从索引0开始到索引3的所有元素,并不遵从左闭右开原则；反向切片索引：lrange key -3 -1，该语法表示获取获取最后三个元素；正反向混合索引：lrange key 0 -2，该语法表示获取从0索引开始，截止到倒数第二个元素位置的所有元素。

​	集合（set）：key：{value1，value2，value3、、、}；key作为redis的key，对应存储的也是大量value，不同的是set中的元素是唯一的，通过计算hash的方式将元素唯一，即两个元素的hash值如果一样就默认为同一元素。其存储容量也是2的32次方-1，因为是通过hash表实现的，因此其存储是无序的，使用起来会很不方便。基于以上特点，集合也并非一无是处，可以通过set去重，redis支持两个集合间的操作，通过redis命令可以得出交集、并集、差集等数据然后存储到一个新的集合中。

​	有序集合（sorted set）：与集合的区别就在于它是有序的，通过额外的开销得到的有序，将每个元素都关联一个分数，通过分数进行排序，即命令：ZADD key score value；Zadd表示添加一个元素，key则表示该set的对应redis的key，score表示分数（可以重复，根据分数大小排序以及添加索引），value则是需要存储的value；因为是通过分数得到的排序，因此相对set的api多了一些基于分数与索引的操作，其余方面与set并无区别。额外提一下关于有序集合可以使用的业务场景：排行榜；通过zincrby key score sortnam命令即可简单实现；该命令表示，向zset指定的key中根据sortnam添加分数；zset默认升序，只需通过zrange key startindex endIndex 截取最后需要排行的位数即可。

​	关于redis的使用命令可以通过查看官方文档的方式了解更多，更简单的可以通过菜鸟教程更直观的示例学习使用。

​	redis的分布式锁可以由setnx命令实现，该命令的特点是若key不存在,则设置value并且返回1，若key存在，则无法设置value并返回0。基于该特点，可以轻易实现分布式锁：对redis的操作都先对锁key进行操作，若返回1，则锁不存在，可以进行操作，若返回0，则锁存在，不允许操作，等到锁释放后再进行操作。但是该策略存在死锁隐患，若拿到锁的系统挂了，来不及释放锁，那么锁就会成为死锁，其它的系统就无法获取redis的操作权。为此,应该针对这种可能发生的现象对锁添加超时自动释放，获取到锁的同时立即设置过期时间再执行操作，操作完成后手动释放锁，若服务器挂掉由设置的超时释放，但该解决方案依然存在问题，即获取锁与设置超时并非原子性的操作，如果真的这么巧，在获取锁的时候没来得及设置超时服务器就挂了，上述死锁问题依然存在。redis虽然支持事务，但redis的事务并非原子性的，即多条redis命令，成功的依然成功，失败后后续的命令不再执行，因此无法指望通过事务的方式来解决该问题。redis提供了一组API，可以优雅的解决此问题：SET key value NX PX milliseconds；该命令表示 set key value这个就不用说了，NX表示只有当键key不存在的时候才会设置key的值，PX表示设置键key的过期时间，单位是毫秒。一条命令完成的操作一定是原子性的，在分布式系统中，通过该方式设定指定的key表示锁，任何需要进行redis锁操作的代码中都获取这个锁，若该锁对应的value存在则锁存在,不允许操作，若该锁对应的value不存在则锁不存在，设置锁并进行操作。

​	redis虽然是内存数据库，但它同样提供了两种策略支持数据的持久化：RDB与AOF。

​	RDB：指定时间段对redis内存进行快照通过fork出子进程将redis中的数据输出到硬盘文件中，一旦redis服务器发生故障，可以将备份文件转移到其它服务器进行恢复，相较于AOF，恢复效率会更加稳定。缺点就在于若redis服务器发生故障，内存中的数据还未到持久化的时间点没来的及写出到文件，那么这段时间内的数据将会丢失。

​	AOF：该持久化策略采用的方式是记录命令；记录redis的操作命令，将其写入到文件中；AOF支持每秒同步、每次修改同步，因此可以带来更好的数据持久性与安全性。每秒同步实际上做得事就是将这一秒中对于redis的命令记录在内存中到时间后异步写出到文件，因此效率也是不错的，但是存在和RDB一样的问题，服务器挂了以后记录的命令来不及写出就丢了；而每次记录同步则是将每次对于redis的操作同时写出到文件中，因此该持久化方式效率是整体来说效率最低安全性最高的。因为持久化的是redis命令,因此相较于RDB纯粹的备份数据会有很多冗余，因此恢复效率会不如RDB。

​	redis支持主从备份这种机制，因此可以对以上持久化进行优化，主服务器负责读写操作，从服务器负责备份主服务器的数据并进行持久化操作。

​	关于redis集群官方推荐使用Redis-Cluster，该策略采用无中心结构，每个节点保存数据与整个集群状态，每个节点和所有节点连接；redis集群内置了16384个哈希槽,分配到集群的服务器上，通过计算key对应的哈希槽的值分配到对应的具体的集群中的服务器存储，例如，服务器1的哈希槽值为0-5000，计算key的哈希槽值为3000，于是就分配到这台服务器上存储；数据存储服务器都会容错机制，在redis集群中，若主服务器挂掉，由从服务器顶上。