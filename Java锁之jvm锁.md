加锁原理：
    通过monitorenter或者monitorexit对关联的对象的锁计数加一或者减一。
    每个对象都有个monitor与之相关联，monitor只能被一个线程获取。
    当线程尝试获取锁时，如果锁计数为0，则会直接获取到锁，并通过monitorenter对锁计数加一。
    当线程已经获取到锁时并尝试再次获取锁时，就会对锁计数自增加一。
    当线程释放锁时，则会相应的通过monitorexit对锁计数自减减一。当归0后，线程则会释放锁。
    此时其它的线程就可以获取该锁。
锁级别：
    无锁、偏向锁、轻量级锁、重量级锁
    Java的对象对象头里会包含如下部分，mark word,指向对象的引用（指针），如果是数组对象还会包含数组长度
    其中mark word记录了对象的锁信息
    无锁时包含对象的hashcode 偏向锁标记 对象年龄等信息
    偏向锁时包含线程ID 偏向锁标记 对象年龄 锁级别信息
    轻量级锁时 线程会拷贝一份锁对象的mark word到自己栈中的lock record中 锁对象的栈中引用指针 锁级别信息
    重量级锁锁时 锁对象的引用指针 锁级别信息
jvm加锁过程
    无锁时通过cas指令直接获取锁 设置偏向锁标记与线程ID 
    偏向锁时比较线程ID 如果是则省去cas指令 如果不是则升级为轻量级锁
    轻量级锁时 则尝试通过cas指令获取锁，如果获取失败，则会自旋，如果自旋失败则会升级为重量级的互斥锁
jvm锁优化：
    锁级别优化 （最糟糕时才会升级为重量级的互斥锁）
    锁消除 逃逸分析，不会有线程安全问题时去掉锁
    锁合并 连续的小锁合并为一个大锁，省去频繁的锁开销
    自旋 如果没有获取到锁则自旋等待锁释放
    自适应自旋 对自旋的优化，jvm会记录每次成功自旋获取锁的开销 然后减少相应的自旋开销