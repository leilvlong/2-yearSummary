谈谈es搜索引擎的使用

​	“大型Web项目”必定会有搜索功能，这个“大型Web项目”可以是一点点迭代上去的，随着版本的升级，搜索引擎对于用户体验优化、网站性能优化的重要性会越来越高。需要被搜索的数据具有的特点：目标范围内的不确定性；即你知道用户会搜索那个范围内的数据，但具体的数据是未知的，倘若我们使用sql的模糊查询，这在数据量小的时候没什么问题，但是数据量一大，Mysql内部采用的B+数结构，其性能可想而知。

​	搜索引擎就是用来解决上述问题的，es作为一款免费的全文检索的分布式搜索引擎，不仅性能稳定，而且生态丰富；同类产品solr作为一款成熟的老产品，在数据量小的时候，性能很好，查询快，但是一旦数据量大，其稳定性就不如es，而且es的生态圈支持对es存储库的大数据处理。以下对solr与es做一个全面的对比。

​	solr使用zookeeper做注册中心进行分布式管理，es自身并带有分布式协调管理；solr支持更多的数据文档格式，es只支持Json格式的数据文档，solr官方提供了很多额外的功能，es专注搜索的实现，额外的功能由第三方插件提供；solr在传统的搜索上性能要好于es，但是在实时数据处理与搜素上性能比es差很多；es支持restful风格搜索，solr暂不支持。互联网行业永远都在追求新技术，其重要指标就是灵活度与稳定性，这上述对比中已然得出结果。两款产品都是基于apach提供的lucene的API去实现的，下文将对lucene与es做简单而全面的说明。

​	在介绍lucene时先说说数据查询方法。顺序扫描法：顾名思义，对数据逐条扫描，类似于sql语句中like的全表扫描；倒排索引：将需要被搜索的数据导入到一个全新的索引库中，按照指定规则进行细分数据内容，建立索引，根据索引找到对应的数据，这样的切分必定会有重复部分，为此会针对索引去重，并将包含该索引的内容的数据存储位置记录下来。上述两种查询方式做个比较的话，可以采用一个例子：有两本新华字典，一本目录都被撕掉了，一本目录没有撕掉，现在需要查询《凹》这个字的内容，哪个会更快更稳定？至于哪一种查询方式对应有目录的，哪一种查询方式对应没目录的，不用想都知道。

​	lucene正是基于倒排索引这种方式去封装的API，之所以说是API是因为lucene真的只是API，它提供了一些接口与简单的增删改查操作，以及简单的存储库的创建，相较于对搜索引擎性能的需求，它并不能满足。关于lucene的API的使用，这里就不介绍了，毕竟没有使用场景，对其有个基本的认识即可，更详细的可以查阅官方文档。这里需要重点阐述的是分词器，前文提过，会将数据内容进行细分，这种细分对原数据不变，只是为了建立索引，而分词器就是建立索引的规则，它允许开发者自己去实现，自身API提供的分词提供了一些过滤规则：如停用词 a、an、the、is等，提供标点符号的过滤等等，其具体流程为：数据→分词→标准过滤→大小写过滤→停用词过滤。数据库中的数据都会有多个字段，这些在lucene存储库中可以一一对应，并且可以设置哪些字段不分词，比如说：手机号、身份证号等。当然了，这类隐私数据也不能拿来做搜索，只是举例而已。

​	以下是es存储库与数据库的对应关系：

​		Relational DB -> databases -> tables -> rows -> columns

​		Elasticsearch -> indices   -> types  -> documents -> fields

​	从上述关系中可以看出：databases对应indices；tables对应types；rows对应documents；ccolumns对应fields。以上对应关系中与java息息相关的就是rows与documents，一个row或者documents对应一个java的pojo对象，而不管是DB还是elastisaerch都是以java的pojo对象为存储单位。但是需要明白es在存储document时并不是单纯的类似于数据库存储时的那样成行成列，它允许对document进行索引、搜索、排序、过滤。

​	es是基于lucene的再封装，提供强大而稳定的搜索功能，使用es的API时对一些核心概念先做了解。

​	文档（doument）：es中基础的可以被索引的存储信息单元,文档以Json的数据格式表示。

​	索引（index）：一个索引对应的是多个有相似类容的document的集合，前文提过，多条数据必定有重复的部分，他们会被分到一个索引下，由该索引记录存储地址，使用该索引，便可以得到这些数据，这些document在数据中可以是不同表的，但是他们都一定会有某部分特征相同，而一个索引由一个名字标识（必须全部是小写字母），使用该名字就可以对该索引的document增删改查。

​	类型（type）：一个索引中可以定义多个类型，这些document尽管具有相同的特征，但是因为是最基础的信息单元，分到各自的类型下更利于搜索。

​	字段（field）：一个文档拥有多个字段，这并不改变文档是最基础的信息单元这一定义。准确来说，文档的内容就是这些字段，因此对于字段有相当多的映射操作用来决定数据的处理方式与限制：字段的数据类型、默认值、分词器、是否被索引等等。按照这些规则，可以大大优化性能；可以这样理解：对这些字段的优化相当于对sql查询语句的性能优化（尽管这个举例并不对，但是为了说明field合理使用映射的重要性）

​	在实际项目开发中，对于es的API的使用，其实并不简单，至少初次下手时便是如此，在我第一次使用es的API时，几乎是连蒙带猜，其主要原因是es的API被划为两个部分：spring data elasticsearch、 elasticsearch官方提供的javadocs。

​	spring data elasticsearch对于集成elasticsearch的使用非常简单，官方提供了大量的案例：xml配置可以照抄官方文档，使用pojo映射es存储库的doument对象时应当使用一些注解标明,这些也可以在官方文档中找到，然后通过对应的Dao继承ElasticsearchRepository即可，只需如此就可以开始简单的搜索使用了。

​	麻烦就麻烦在构建多条件查询，不得不使用elsticsearchTemplate，使用该API允许构建查询模板，但是查询模板的条件都是由elasticsearch官方提供的javadocs，为此，不得不两头看，一点一点测；倘若写错了搜索条件，那就真的是遇到了最麻烦的问题：代码没有错，就是结果不对。以下是elasticsearch官方提供的（事实上官方并不提供，结合包名与es官网地址才找到的）javadocs的地址，中间的数字代表版本，可以自行更改对应使用的版本：<https://artifacts.elastic.co/javadoc/org/elasticsearch/elasticsearch/5.6.16/overview-summary.html>。

​	