# 工作线程

##### Masteer Thread：

​	将数据从缓冲池刷到磁盘中，保证数据的一致性

​	脏页的刷新

​	合并插入缓冲

​	undo页的回收

##### IO Thread

​	使用Async IO处理写请请求（提升性能）

​	对IO请求进行异步回调（read、write、insert buff、IO log Thread）

##### Purge Thread

​	对事务提交后的使用的undolog可能不再需要，对undo页进行回收（减轻主线程的工作）

##### Page Cleaner Thread

​	对脏页进行刷新（目的是为了减轻主线程的工作及阻塞用户查询线程的请求）

# 内存

##### 重做日志缓冲内存

​	存储引擎工作产生的日志并不会直接写入日志文件中，而是存储在重做日志缓冲内存中，以一定频率刷出到日志文件中。

​	Master Thread 每秒刷出一次

​	当有事务提交时立即刷出

​	当剩余空间小于配置参数指定空间内存的二分之一时

​	重做日志用来保证数据的持久性（对于脏页而言）

##### 额外的内存池

​	在innodb存储引擎中，对内存的管理是以内存堆的方式进行的，当需要对一些数据结构分配内存时，就会从该内存池中分配，若该内存池不足，则将会从缓冲池中获取

##### 缓冲池

​	索引页

​	数据页

​	插入缓冲

​	自适应哈希

​	数据字典

​	undo页

​	Innodb存储的所信息。。。。。。

​	为了更加高效使用磁盘文件而存在的内存区域

​	可以有多个缓冲池实例，根据hash算法分配数据页到不同的缓冲池实例中，减少内部资源竞争，增加并发能力

​	缓冲池采用最近最少使用算法来进行管理

​	LRU list、Free list、Flush list

​	Innodb对于最近最少使用算法进行了优化，增加了midpoint

​	midpoint之前是new list（最近数据列表），之后是old list（最少使用数据列表）

​	midpoint可由参数控制(预估热点数据的比例而配置该参数)

​	新数据则加入到minpoint附近（介于新旧数据列表交界之间）

​	为了防止某些sql操作将缓冲池中的最近数据列表数据大量刷出导致命中率降低而采取这一优化方式（全表扫描）

​	缓冲池中的数据命中率达到95%是合理的，95%以下都有优化的空间

​	LRU list用来管理已经读取的页

​	数据库刚启动时 LRU list为空列表，此时页都在Free list中，当需要从缓冲分页时，会先到Free list查找可用的空闲页，若有，将该页从Free list中删除，添加到LRU list中,，如果没有，则对LRU list采用LRU算法

​	LRU列表中的页被修改，被称为脏页，Flush列表中的页为脏页列表，当脏页产生时，通过Checkpoint机制，将脏页刷到磁盘，做持久化，保证数据的一直性。需要注意的是，脏页即存在于LRU列表中，也存在于Flush列表中。LRU列表中的脏页保证可用性，Flush列表中的脏页则被用于刷出到磁盘中，两者互不影响。

# Checkpoint技术

​	用于将脏页刷新到磁盘中的技术，若每次发生脏页，立即刷新到磁盘，开销过大，数据库的性能会很差，因此只有达到一定数量的数据脏页才会触发该机制。为了确保这段时间内数据不会丢失，事务数据库采用Write Ahead Log策略。先写日志，然后再对数据进行修改。当发生宕机等不可控事故时，可通过日志对数据进行恢复，这也是ACID中D的要求。

​	使用日志和缓冲池技术看似可以解决数据的持久性与存储问题，但是随着业务持续运行，数据量增大，缓冲池不可能存储所有数据（Nosql产品的问题），同时日志文件无限增大，一旦宕机，数据恢复也会是个大问题。

​	Checkpoint技术解决以下问题：

​		缩短数据库恢复时间

​		缓冲池不够用时，将脏页刷新到磁盘中

​		重做日志出现不可用时，刷新脏页

​	当数据库发生宕机时，数据库不需要重做所有的日志，因为Checkpoint之前的页都已经刷新回磁盘了，只需对没有Checkpoint标记的日志进行恢复即可

​	当缓冲池不够用时，会使用LRU算法，若淘汰的（溢出的）页为脏页，则强制执行Checkpoint

​	当前事务数据库系统对重做日志系统采用的策略都是循环使用，日志无限增大从成本以及管理上困难很大。重做日志可以被重用的部分指的是已经不需要的部分（被刷新到磁盘中的已经持久化的，数据库宕机时不需要恢复的日志），若重做日志没有写入的空间，则强制执行Checkpoint，腾出空间

​	Innodb存储引擎通过LSN（log sequence number)来标记版本的，LSN为8字节的数字，每个页有LSN，Checkpoint有LSN，重做日志中也有LSN。

​	Checkpoint所做的事就是将脏页刷新到磁盘，其工作方式为两种：

​		Sharp Checkpoint

​		Fuzzy Checkpoint

​	Sharp Checkpoint是将所有的脏页刷新到磁盘中，默认设置为只有当数据库关闭时执行该操作，若在正常情况下使用，因为刷新脏页会阻塞用户查询线程，导致工作效率低下

​	Fuzzy Checkpoint则是将一部分脏页刷新到磁盘中，是数据库运行时使用Checkpoint，该Checkpoint又会在以下情况进行脏页刷新：

​		Master Thread Checkpoint

​		FLUSH_LRU_LIST Checkpoint

​		Async/Sync Checkpoint

​		Dirty Page too much Checkpoint

​	Master Thread中发生的Checkpoint以每秒或每十秒左右的速度从缓冲池的脏页列表中刷新一定比例的脏页该过程是异步的，不会阻塞查询线程

​	FLUSH_LRU_LIST Checkpoint是因为Innodb引擎要检查保证LRU列表中有足够的空闲页可供使用，因为检查发生在用户查询线程中，因此会阻塞用户查询，倘若没有足够多的空闲页，根据LRU算法，移除尾端的页，若有脏页，则进行Checkpoint，在5.6版本以后，该检查放在单独的线程中进行

​	Async/Sync Checkpoint 则是在重做日志文件不可用时，强制将一些脏页刷新到磁盘，腾出重做日志文件的空间

​	Dirty Page too much Checkpoint 则是指当脏页的数量太多时，强制进行Checkpoint。

​	

# Innodb的关键特性

##### insert buffer(插入缓冲)

##### 两次写

##### 异步IO

##### 刷新连接页

##### 自适应hash索引

# Master Thread的工作方式

# 索引

##### B+树索引

聚集索引（通过索引组织表将数据有序的聚集，组织起来）

​	innodb采用索引组织表，即表中的数据按照主键顺序存放，而聚集索引就是按照表的主键构造的B+树，叶子节点中存放的为表中的行数据记录，聚集索引的叶子节点也被称为数据页，同样因为是B+树结构的关系，因此只能有一个聚集索引（只能有一种排序方式）。因为是b+树数据结构,因此每个叶子节点都通过双向链表连接。数据库的优化器也更倾向于使用聚集索引做查询优化，因为有序的原因，范围查询也更容易，以及更利于使用二分查找

辅助索引

​	对聚集索引建立的索引，也称二级索引，也是一颗b+树，只不过叶子节点中存放的是是找到该索引对应的聚集索引，再通过聚集索引获取行数据

##### 支持全文索引（倒排索引）

​	只支持有词界定符的语言，不支持象形文字

# 分区

##### Range 分区

##### List 分区

##### hash 分区

##### key 分区

# 锁

共享锁

排他锁

意向共享锁

意向排他锁

锁算法

脏读

不可重复读

一致性非锁定读

一致性锁定读

丢失更新（客户端问题）







```
(1,1,1)
(1,1,2)
(1,2,1)
(1,2,2)
(2,1,1)
(2,1,2)
(2,2,1)
(2,2,2)

a = 1 1 1 1 2 2 2 2
b = 1 1 2 2 1 1 2 2
c = 1 2 1 2 1 2 1 2



```

